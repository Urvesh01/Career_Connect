"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = default_1;
const ts = __importStar(require("typescript"));
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const cli_core_1 = require("@igniteui/cli-core");
const angular_templates_1 = require("@igniteui/angular-templates");
const cli_config_1 = require("../utils/cli-config");
const NgFileSystem_1 = require("../utils/NgFileSystem");
const theme_import_1 = require("../utils/theme-import");
function getDependencyVersion(pkg, tree) {
    const targetFile = "/package.json";
    if (tree.exists(targetFile)) {
        const sourceText = tree.read(targetFile).toString();
        const json = JSON.parse(sourceText);
        let targetDep;
        if (json.dependencies[pkg]) {
            targetDep = json.dependencies[pkg];
        }
        else if (json.devDependencies[pkg]) {
            targetDep = json.devDependencies[pkg];
        }
        else {
            targetDep = json.peerDependencies[pkg];
        }
        if (!targetDep) {
            throw new core_1.DependencyNotFoundException();
        }
        return targetDep;
    }
    throw new schematics_1.FileDoesNotExistException(`${tree.root.path}/${targetFile}`);
}
function displayVersionMismatch() {
    return (tree, context) => {
        const igxPackage = (0, cli_core_1.resolvePackage)(cli_core_1.NPM_ANGULAR);
        const pkgJson = JSON.parse(tree.read(`/node_modules/${igxPackage}/package.json`).toString());
        const ngKey = "@angular/core";
        const ngCommonKey = "@angular/common";
        const ngCoreProjVer = getDependencyVersion(ngKey, tree);
        const ngCommonProjVer = getDependencyVersion(ngCommonKey, tree);
        const ngCoreVer = pkgJson.peerDependencies[ngKey];
        const ngCommonVer = pkgJson.peerDependencies[ngCommonKey];
        if (ngCoreProjVer < ngCoreVer || ngCommonProjVer < ngCommonVer) {
            context.logger.warn(`
WARNING Version mismatch detected - ${igxPackage} is built against a newer version of @angular/core (${ngCoreVer}).
Running 'ng update' will prevent potential version conflicts.\n`);
        }
    };
}
function addTypographyToProj() {
    return (tree) => {
        (0, cli_core_1.addClassToBody)(tree, "ig-typography");
        (0, cli_core_1.addClassToBody)(tree, "ig-scrollbar");
    };
}
function importBrowserAnimations() {
    return (tree) => __awaiter(this, void 0, void 0, function* () {
        const projects = yield (0, theme_import_1.getProjects)(tree);
        projects.forEach(project => {
            // TODO: Resolve hardcoded paths instead
            const moduleFilePath = `${project.sourceRoot}/app/app.module.ts`;
            if (tree.exists(moduleFilePath)) {
                const mainModule = new angular_templates_1.AngularTypeScriptFileUpdate(moduleFilePath, false, {
                    indentSize: 4,
                    convertTabsToSpaces: false,
                    singleQuotes: false
                });
                mainModule.addNgModuleMeta({ import: "BrowserAnimationsModule", from: "@angular/platform-browser/animations" });
                mainModule.finalize();
            }
            const appConfigFilePath = `${project.sourceRoot}/app/app.config.ts`;
            if (tree.exists(appConfigFilePath)) {
                const sourceFile = cli_core_1.TypeScriptUtils.getFileSource(appConfigFilePath);
                const formatSettings = {
                    indentSize: 4,
                    convertTabsToSpaces: false,
                    singleQuotes: false
                };
                const configTransformer = new cli_core_1.TypeScriptAstTransformer(sourceFile, undefined, undefined, formatSettings);
                const providerMeta = { provide: "provideAnimations", from: "@angular/platform-browser/animations" };
                if (!configTransformer.importDeclarationCollides({ name: providerMeta.provide })) {
                    configTransformer.requestNewImportDeclaration({
                        identifiers: { name: providerMeta.provide },
                        moduleName: providerMeta.from
                    });
                }
                configTransformer
                    .requestNewMembersInArrayLiteral((node) => !!configTransformer.findNodeAncestor(node, (node) => ts.isPropertyAssignment(node) &&
                    node.name.getText() === "providers" &&
                    ts.isObjectLiteralExpression(node.parent) &&
                    ts.isArrayLiteralExpression(node.initializer) &&
                    !node.initializer.elements.some(el => ts.isCallExpression(el) && el.expression.getText() === providerMeta.provide) &&
                    node.initializer.elements.some(el => ts.isCallExpression(el) && el.expression.getText() === "provideRouter")), [ts.factory.createCallExpression(ts.factory.createIdentifier(providerMeta.provide), undefined, [])]);
                const result = configTransformer.finalize();
                cli_core_1.TypeScriptUtils.saveFile(appConfigFilePath, result);
            }
        });
    });
}
function importStyles() {
    return (tree) => __awaiter(this, void 0, void 0, function* () {
        yield (0, theme_import_1.addFontsToIndexHtml)(tree);
        yield (0, theme_import_1.importDefaultTheme)(tree);
    });
}
// tslint:disable-next-line:space-before-function-paren
function default_1() {
    return (tree) => {
        (0, NgFileSystem_1.setVirtual)(tree);
        return (0, schematics_1.chain)([
            importStyles(),
            addTypographyToProj(),
            importBrowserAnimations(),
            (0, cli_config_1.createCliConfig)(),
            displayVersionMismatch()
        ]);
    };
}
