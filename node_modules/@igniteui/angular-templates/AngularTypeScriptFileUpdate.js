"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AngularTypeScriptFileUpdate = void 0;
const ts = __importStar(require("typescript"));
const cli_core_1 = require("@igniteui/cli-core");
const types_1 = require("./types");
class AngularTypeScriptFileUpdate extends cli_core_1.TypeScriptFileUpdate {
    /**
     * Creates a new AngularTypeScriptFileUpdate instance for the given file.
     * @param standalone Whether the file is a standalone component.
     * @param formatSettings Custom formatting settings to apply.
     */
    constructor(filePath, standalone = false, formatSettings, compilerOptions) {
        super(filePath, formatSettings, compilerOptions);
        this.filePath = filePath;
        this.standalone = standalone;
        this.formatSettings = formatSettings;
    }
    //#region Public API
    /**
     * Adds a route entry to the Angular routing module's routes variable instance.
     * @param route The route to add.
     * @param multiline Whether to format the new entry as multiline.
     * @param prepend Whether to insert the new entry before the anchor element.
     *  If no anchor is provided, the new entry will be added to the start or end of the array.
     * @param anchorElement The anchor element to insert to.
     */
    addRoute(route, multiline = false, prepend = true, anchorElement = cli_core_1.ANCHOR_ELEMENT) {
        if (!route.lazyload) {
            this.requestImportForRouteIdentifier(route);
        }
        const structure = this.buildRouteStructure(route, multiline);
        const newRoute = this.factory.createObjectLiteralExpression(structure, multiline);
        this.astTransformer.requestNewMembersInArrayLiteral((0, cli_core_1.variableAsParentCondition)(this.astTransformer, cli_core_1.ROUTES_VARIABLE_NAME), [newRoute], anchorElement, { prepend });
    }
    addChildRoute(parentPath, route, asIdentifier = false, multiline = false) {
        super.addChildRoute(parentPath, route, asIdentifier, multiline);
    }
    /**
     * Adds an import identifier to a standalone component's metadata.
     * @param dep The dependency to add to the standalone component's metadata.
     * @param variables Variables to replace in the dependency strings.
     * @param multiline Whether to format the new entry as multiline.
     */
    addStandaloneComponentMeta(dep, variables, multiline = false) {
        if (!this.standalone || !dep.standalone)
            return;
        const copy = {
            imports: this.asArray(dep.import || [], variables || {}),
            providers: this.asArray(dep.provide || [], variables || {}),
            schemas: this.asArray(dep.schema || [], variables || {}),
        };
        if (dep.from) {
            this.addImportDeclarationForDependency(copy, dep.from, variables);
        }
        this.applyDecoratorMutations(cli_core_1.NG_SA_DECORATOR_NAME, copy, multiline);
    }
    /**
     * Adds metadata to an NgModule decorator.
     * @param dep The dependency to add to the NgModule decorator.
     * @param variables Variables to replace in the dependency strings.
     * @param multiline Whether to format the new entry as multiline.
     */
    addNgModuleMeta(dep, variables, multiline = false) {
        if (this.standalone || dep.standalone)
            return;
        const copy = {
            imports: this.asArray(dep.import || [], variables || {}),
            declarations: this.asArray(dep.declare || [], variables || {}),
            providers: this.asArray(dep.provide || [], variables || {}),
            exports: this.asArray(dep.export || [], variables || {}),
            schemas: this.asArray(dep.schema || [], variables || {}),
        };
        if (dep.from) {
            this.addImportDeclarationForDependency(copy, dep.from, variables);
        }
        this.addRootToModule(dep, copy);
        this.applyDecoratorMutations(cli_core_1.NG_MODULE_DECORATOR_NAME, copy, multiline);
    }
    /**
     * Sorts the elements of an Angular decorator property that is an {@link ts.ArrayLiteralExpression}.
     * @param decoratorName The name of the decorator to look for.
     * @param target The target metadata property to sort.
     *
     * @remarks The {@link target} must be a {@link ts.PropertyAssignment} with an initializer that is an {@link ts.ArrayLiteralExpression}.
     */
    sortDecoratorPropertyInitializer(decoratorName, target) {
        const visitCondition = (node) => {
            const propertyAssignment = this.astTransformer.findNodeAncestor(node, (node) => ts.isPropertyAssignment(node) &&
                ts.isIdentifier(node.name) &&
                node.name.text.toLowerCase() === target.toLowerCase() &&
                ts.isArrayLiteralExpression(node.initializer));
            if (!propertyAssignment) {
                return false;
            }
            const expectedDecorator = this.checkNgDecorator(decoratorName, node);
            return expectedDecorator;
        };
        const igxMembersPrefix = 'igx';
        this.astTransformer.requestSortInArrayLiteral(visitCondition, (a, b) => {
            // this check is just to type guard to a ts.Identifier
            // in reality, the elements should always be identifiers
            if (!ts.isIdentifier(a) || !ts.isIdentifier(b))
                return -1;
            const aText = a.text.toLowerCase();
            const bText = b.text.toLowerCase();
            if (aText.startsWith(igxMembersPrefix) &&
                !bText.startsWith(igxMembersPrefix)) {
                return 1;
            }
            else if (!aText.startsWith(igxMembersPrefix) &&
                bText.startsWith(igxMembersPrefix)) {
                return -1;
            }
            else {
                return aText.localeCompare(bText);
            }
        });
    }
    /**
     * Adds metadata to the arguments provided in `TestBed.configureTestingModule`.
     * @param dep The dependency to add to the testing module's metadata.
     * @param variables Variables to replace in the dependency strings.
     * @param multiline Whether to format the new entry as multiline.
     */
    addTestingModuleMeta(dep, variables, multiline = false) {
        const copy = {
            imports: this.asArray(dep.import || [], variables || {}),
            declarations: this.asArray(dep.declare || [], variables || {}),
            providers: this.asArray(dep.provide || [], variables || {}),
            exports: this.asArray(dep.export || [], variables || {}),
            schemas: this.asArray(dep.schema || [], variables || {}),
        };
        if (dep.from) {
            this.addImportDeclarationForDependency(copy, dep.from, variables);
        }
        if (!this.standalone) {
            this.addRootToModule(dep, copy);
        }
        const parentIsConfigureTestingModule = (node) => {
            return !!this.astTransformer.findNodeAncestor(node, (_node) => {
                return (ts.isCallExpression(_node) &&
                    ts.isPropertyAccessExpression(_node.expression) &&
                    ts.isIdentifier(_node.expression.name) &&
                    _node.expression.name.text === cli_core_1.NG_CONFIG_TESTING_MODULE);
            });
        };
        const findTargetMetaProp = (propName) => this.astTransformer.findPropertyAssignment((node) => ts.isIdentifier(node.name) &&
            node.name.text === propName &&
            parentIsConfigureTestingModule(node));
        for (const key of Object.keys(copy)) {
            const targetMetaProp = findTargetMetaProp(key);
            const identifiers = copy[key].map(ts.factory.createIdentifier);
            if (copy[key].length > 0) {
                this.mutateNgMeta(key, targetMetaProp, identifiers, parentIsConfigureTestingModule, multiline);
            }
        }
    }
    /**
     * Includes `{ bindToComponentInputs: true }` for a `forRoot` call in an `NgModule`'s `imports` member.
     *
     * For standalone projects, includes an `withComponentInputBinding` call in a `providers` variable. Mainly present in an `app.config` file.
     */
    allowComponentInputBinding() {
        if (this.standalone) {
            this.astTransformer.requestNewImportDeclaration({
                identifiers: [{ name: cli_core_1.WITH_COMPONENT_INPUT_BINDING }],
                moduleName: cli_core_1.NG_ROUTER_PACKAGE,
            });
            // create withComponentInputBinding()
            const callExpr = ts.factory.createCallExpression(ts.factory.createIdentifier(cli_core_1.WITH_COMPONENT_INPUT_BINDING), undefined, // type args
            [] // args
            );
            this.astTransformer.requestNewArgumentInMethodCallExpression((node) => ts.isIdentifier(node.expression) &&
                node.expression.text === cli_core_1.PROVIDE_ROUTER &&
                (0, cli_core_1.variableAsParentCondition)(this.astTransformer, cli_core_1.NG_DECORATOR_PROVIDERS)(node), callExpr);
        }
        else {
            const objLiteral = this.factory.createObjectLiteralExpression([{ bindToComponentInputs: cli_core_1.TRUE_CLAUSE }], false, // multiline
            () => ts.factory.createTrue());
            this.astTransformer.requestNewArgumentInMethodCallExpression((node) => ts.isPropertyAccessExpression(node.expression) &&
                ts.isIdentifier(node.expression.name) &&
                node.expression.name.text === cli_core_1.NG_FOR_ROOT_IDENTIFIER_NAME &&
                this.checkNgDecorator(cli_core_1.NG_MODULE_DECORATOR_NAME, node), objLiteral);
        }
    }
    /**
     * Provides the `HttpClient` for standalone applications.
     */
    provideHttpClientForStandaloneAppConfig() {
        this.astTransformer.requestNewImportDeclaration({
            identifiers: [{ name: cli_core_1.NG_HTTP_CLIENT_PROVIDER }],
            moduleName: cli_core_1.NG_COMMON_HTTP_PACKAGE,
        });
        // create provideHttpClient()
        const callExpr = ts.factory.createCallExpression(ts.factory.createIdentifier(cli_core_1.NG_HTTP_CLIENT_PROVIDER), undefined, // type args
        [] // args
        );
        this.astTransformer.requestNewMembersInArrayLiteral((0, cli_core_1.variableAsParentCondition)(this.astTransformer, cli_core_1.NG_DECORATOR_PROVIDERS), [callExpr]);
    }
    //#endregion
    //#region Protected Overrides
    buildRouteStructure(route, multiline) {
        var _a, _b, _c, _d, _e;
        let structure = [];
        // lazily loaded route
        if (route.lazyload &&
            route.path &&
            route.identifierName &&
            route.modulePath) {
            const lazyLoadedModule = this.factory.createDynamicImport(route.modulePath, route.identifierName);
            const propAssignmentName = route.root
                ? types_1.AngularRouteTarget.LoadChildren
                : types_1.AngularRouteTarget.LoadComponent;
            structure = [
                {
                    name: cli_core_1.RouteTarget.Path,
                    value: ts.factory.createStringLiteral(route.path, (_a = this.formatSettings) === null || _a === void 0 ? void 0 : _a.singleQuotes),
                },
                { name: propAssignmentName, value: lazyLoadedModule },
            ];
        }
        if (route.redirectTo) {
            // redirect route
            structure = [
                {
                    name: cli_core_1.RouteTarget.Path,
                    value: ts.factory.createStringLiteral(route.path || '', (_b = this.formatSettings) === null || _b === void 0 ? void 0 : _b.singleQuotes),
                },
                {
                    name: types_1.AngularRouteTarget.RedirectTo,
                    value: ts.factory.createStringLiteral(route.redirectTo, (_c = this.formatSettings) === null || _c === void 0 ? void 0 : _c.singleQuotes),
                },
            ];
            if (route.pathMatch) {
                structure.push({
                    name: types_1.AngularRouteTarget.PathMatch,
                    value: ts.factory.createStringLiteral(route.pathMatch, (_d = this.formatSettings) === null || _d === void 0 ? void 0 : _d.singleQuotes),
                });
            }
        }
        else if (!route.lazyload) {
            // default route
            structure = [
                {
                    name: cli_core_1.RouteTarget.Path,
                    value: ts.factory.createStringLiteral(route.path, (_e = this.formatSettings) === null || _e === void 0 ? void 0 : _e.singleQuotes),
                },
                {
                    name: cli_core_1.RouteTarget.Component,
                    value: ts.factory.createIdentifier(route.aliasName || route.identifierName),
                },
            ];
        }
        if (route.data) {
            structure.push({
                name: types_1.AngularRouteTarget.Data,
                value: this.factory.createObjectLiteralExpression([route.data], multiline, (value) => {
                    var _a;
                    return ts.factory.createStringLiteral(value, (_a = this.formatSettings) === null || _a === void 0 ? void 0 : _a.singleQuotes);
                }),
            });
        }
        return structure;
    }
    //#endregion
    //#region Internals
    /**
     * Add an imort declaration for the dependency.
     * @param meta The metadata to use for the import declaration.
     * @param moduleName The name of the module to import from.
     * @param variables Variables to replace in the dependency strings.
     */
    addImportDeclarationForDependency(meta, moduleName, variables) {
        // add an import declaration for the dependency
        const uniqueIdentifiers = new Set(Object.values(meta).flat());
        const identifiers = [...uniqueIdentifiers].map((name) => ({ name }));
        this.astTransformer.requestNewImportDeclaration({
            identifiers,
            moduleName: this.applyConfigTransformation(moduleName, variables),
        });
    }
    /**
     * Applies mutations to an Angular decorator's metadata.
     * @param decoratorName The name of the decorator to update.
     * @param meta The metadata to use for the mutations.
     * @param multiline Whether to format the new entry as multiline.
     */
    applyDecoratorMutations(decoratorName, meta, multiline = false) {
        for (const key of Object.keys(meta)) {
            if (meta[key].length > 0) {
                this.addMetaToNgDecorator(decoratorName, meta[key], key, multiline);
            }
        }
    }
    /**
     * Updates an Angular decorator's metadata.
     * @param name The name of the decorator to update.
     * @param meta Names of identifiers to be added.
     * @param target The target metadata property to update.
     * @param multiline Whether to format the new entry as multiline.
     */
    addMetaToNgDecorator(name, meta, target, multiline = false) {
        const identifiers = meta.map(ts.factory.createIdentifier);
        const targetMetaProp = this.findNgDecoratorProperty(name, target);
        this.mutateNgMeta(target, targetMetaProp, identifiers, (node) => this.checkNgDecorator(name, node), multiline);
    }
    /**
     * Updates Angular's metadata related to NgModules, Standalone Components or TestingModules.
     * @param target The name of the target metadata property to update.
     * @param targetMetaProp The property that is to be updated.
     * @param identifiers The identifiers to add.
     * @param visitorCondition The condition to find the object literal that contains the target property.
     * @param multiline Whether to format the new entry as multiline.
     */
    mutateNgMeta(target, targetMetaProp, identifiers, visitorCondition, multiline) {
        const value = targetMetaProp && !ts.isArrayLiteralExpression(targetMetaProp.initializer)
            ? [targetMetaProp.initializer, ...identifiers]
            : identifiers;
        this.astTransformer.requestNewMemberInObjectLiteral(visitorCondition, target, this.factory.createArrayLiteralExpression(value, multiline), { multiline });
    }
    /**
     * Checks if a node has an ancestor with a specific decorator.
     * @param name The name of the decorator.
     * @param node The node to start checking from.
     */
    checkNgDecorator(name, node) {
        const getNodeExpressionTokenName = (node) => {
            const nodeExpression = ts.isDecorator(node) &&
                ts.isCallExpression(node.expression) &&
                node.expression;
            const token = nodeExpression &&
                ts.isIdentifier(nodeExpression.expression) &&
                nodeExpression.expression;
            return ts.isIdentifier(token) && token.text;
        };
        return !!this.astTransformer.findNodeAncestor(node, (node) => getNodeExpressionTokenName(node) === name);
    }
    /**
     * Finds a property assignment that exists in a specific NG decorator meta.
     * @param decoratorName The name of the decorator to check.
     * @param propName The property name to check.
     * @param node The node to start checking from.
     */
    findNgDecoratorProperty(decoratorName, propName) {
        const ngDecoratorExists = (node) => !!this.astTransformer.findNodeAncestor(node, (_node) => {
            const nodeExpressionToken = ts.isDecorator(_node) &&
                ts.isCallExpression(_node.expression) &&
                _node.expression.expression;
            return (ts.isIdentifier(nodeExpressionToken) &&
                nodeExpressionToken.text === decoratorName);
        });
        return this.astTransformer.findPropertyAssignment((node) => ts.isIdentifier(node.name) &&
            node.name.text === propName &&
            ngDecoratorExists(node));
    }
    /**
     * Calls `forRoot` on a module identifier.
     * @param dep The dependency to add to the module's metadata.
     * @param copy The copy of the module's metadata.
     * @param args The arguments to pass to the `forRoot` call.
     */
    addRootToModule(dep, copy, args) {
        if (dep.root && copy.imports.length > 0) {
            // add forRoot to the module
            let forRootArgs = [
                this.factory.createArrayLiteralExpression([]),
            ];
            if (args) {
                forRootArgs = Array.isArray(args)
                    ? args
                    : [this.factory.createArrayLiteralExpression([args])];
            }
            copy.imports = copy.imports.map((i) => this.astTransformer.printer.printNode(ts.EmitHint.Unspecified, this.factory.createCallExpression(i, cli_core_1.NG_FOR_ROOT_IDENTIFIER_NAME, undefined, // type args
            forRootArgs), this.astTransformer.sourceFile));
        }
    }
}
exports.AngularTypeScriptFileUpdate = AngularTypeScriptFileUpdate;
