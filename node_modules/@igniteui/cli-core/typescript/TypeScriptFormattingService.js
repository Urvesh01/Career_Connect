"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeScriptFormattingService = void 0;
const ts = __importStar(require("typescript"));
const types_1 = require("../types");
const util_1 = require("../util");
const TypeScriptUtils_1 = require("./TypeScriptUtils");
class TypeScriptFormattingService {
    /**
     * Create a new formatting service for the given source file.
     * @param path Path to the source file to format.
     * @param formatSettings Custom formatting settings to apply.
     * @param compilerOptions Compiler options to use when transforming the source file.
     */
    constructor(path, formatSettings) {
        this.path = path;
        this.formatSettings = formatSettings;
        this._formatSettingsFromConfig = {};
        this._defaultFormatSettings = {
            indentSize: 4,
            tabSize: 4,
            newLineCharacter: ts.sys.newLine,
            convertTabsToSpaces: true,
            indentStyle: ts.IndentStyle.Smart,
            insertSpaceAfterCommaDelimiter: true,
            insertSpaceAfterSemicolonInForStatements: true,
            insertSpaceBeforeAndAfterBinaryOperators: true,
            insertSpaceAfterKeywordsInControlFlowStatements: true,
            insertSpaceAfterTypeAssertion: true,
            singleQuotes: true,
        };
    }
    /**
     * Apply formatting to a source file.
     */
    applyFormatting(sourceFile) {
        this.readFormatConfigs();
        const languageService = ts.createLanguageService(this.getOrCreateLanguageServiceHost(sourceFile), ts.createDocumentRegistry());
        const changes = languageService.getFormattingEditsForDocument(sourceFile.fileName, this.formatOptions);
        const text = this.applyChanges(TypeScriptUtils_1.TypeScriptUtils.getSourceText(sourceFile), changes);
        TypeScriptUtils_1.TypeScriptUtils.saveFile(this.path, text);
        return text;
    }
    /**
     * The format options to use when printing the source file.
     */
    get formatOptions() {
        return Object.assign({}, this._defaultFormatSettings, this._formatSettingsFromConfig, this.formatSettings);
    }
    /**
     * Creates a language service host for the source file.
     * The host is used by TS to access the FS and read the source file.
     * In this case we are operating on a single source file so we only need to provide its name and contents.
     * @param sourceFile The source file to create the host for.
     */
    getOrCreateLanguageServiceHost(sourceFile) {
        if (this._languageServiceHost)
            return this._languageServiceHost;
        const servicesHost = {
            getCompilationSettings: () => ({}),
            getScriptFileNames: () => [sourceFile.fileName],
            getScriptVersion: (_fileName) => '0',
            getScriptSnapshot: (_fileName) => {
                return ts.ScriptSnapshot.fromString(TypeScriptUtils_1.TypeScriptUtils.getSourceText(sourceFile));
            },
            getCurrentDirectory: () => process.cwd(),
            getDefaultLibFileName: (options) => ts.getDefaultLibFilePath(options),
            readDirectory: () => [],
            readFile: () => undefined,
            fileExists: () => true,
        };
        return servicesHost;
    }
    /**
     * Apply formatting changes (position based) in reverse
     * from https://github.com/Microsoft/TypeScript/issues/1651#issuecomment-69877863
     */
    applyChanges(orig, changes) {
        let result = orig;
        for (let i = changes.length - 1; i >= 0; i--) {
            const change = changes[i];
            const head = result.slice(0, change.span.start);
            const tail = result.slice(change.span.start + change.span.length);
            result = head + change.newText + tail;
        }
        return result;
    }
    /**
     * Try and parse formatting from project `.editorconfig`
     */
    readFormatConfigs() {
        const fileSystem = util_1.App.container.get(types_1.FS_TOKEN);
        const editorConfigPath = '.editorconfig';
        if (fileSystem.fileExists(editorConfigPath)) {
            // very basic parsing support
            const text = fileSystem.readFile(editorConfigPath, 'utf-8');
            if (!text)
                return;
            const options = text
                .replace(/\s*[#;].*([\r\n])/g, '$1') //remove comments
                .replace(/\[(?!\*\]|\*.ts).+\][^\[]+/g, '') // leave [*]/[*.ts] sections
                .split(/\r\n|\r|\n/)
                .reduce((obj, x) => {
                if (x.indexOf('=') !== -1) {
                    const pair = x.split('=');
                    obj[pair[0].trim()] = pair[1].trim();
                }
                return obj;
            }, {});
            this._formatSettingsFromConfig.convertTabsToSpaces =
                options['indent_style'] === 'space';
            if (options['indent_size']) {
                this._formatSettingsFromConfig.indentSize =
                    parseInt(options['indent_size'], 10) ||
                        this._formatSettingsFromConfig.indentSize;
            }
            if (options['quote_type']) {
                this._formatSettingsFromConfig.singleQuotes =
                    options['quote_type'] === 'single';
            }
        }
        // TODO: consider adding eslint support
    }
}
exports.TypeScriptFormattingService = TypeScriptFormattingService;
