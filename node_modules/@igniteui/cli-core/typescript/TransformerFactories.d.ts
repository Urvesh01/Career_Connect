import * as ts from 'typescript';
import { ArrayLiteralExpressionEditOptions, Identifier, ImportDeclarationMeta, ObjectLiteralExpressionEditOptions, PropertyAssignment } from '../types';
import { TypeScriptExpressionCollector } from './TypeScriptExpressionCollector';
/**
 * Transformer factories for updating TypeScript source files.
 * Each factory is responsible for a specific transformation.
 * Each factory is a function that returns a transformer function.
 * The transformer function is responsible for visiting and transforming nodes in the AST.
 * The transformer function is passed to the TypeScript compiler API for processing.
 * The TypeScript compiler API will call the transformer function for each node in the AST.
 * The transformer function will return the transformed node or the original node if no transformation is applied.
 * 	If the transformer function returns `undefined`, `null` the respective node is removed from the AST.
 */
/**
 * Creates a {@link ts.TransformerFactory} that adds a new member to a {@link ts.ObjectLiteralExpression}.
 */
export declare const newMemberInObjectLiteralTransformerFactory: (newProperty: ts.PropertyAssignment, visitCondition: (node: ts.Node) => boolean, expressionCollector: TypeScriptExpressionCollector, options: ObjectLiteralExpressionEditOptions) => ts.TransformerFactory<ts.SourceFile>;
/**
 * Creates a {@link ts.TransformerFactory} that adds a new element to a {@link ts.ArrayLiteralExpression}.
 */
export declare const newMemberInArrayLiteralTransformerFactory: (visitCondition: (node: ts.ArrayLiteralExpression) => boolean, elements: ts.Expression[], anchorElement?: ts.StringLiteral | ts.NumericLiteral | PropertyAssignment, options?: ArrayLiteralExpressionEditOptions) => ts.TransformerFactory<ts.SourceFile>;
/**
 * Creates a {@link ts.TransformerFactory} that sorts the elements in a {@link ts.ArrayLiteralExpression}.
 */
export declare const sortInArrayLiteralTransformerFactory: (visitCondition: (node: ts.ArrayLiteralExpression) => boolean, sortCondition: (a: ts.Expression, b: ts.Expression) => number) => <T extends ts.Node>(context: ts.TransformationContext) => (rootNode: T) => ts.SourceFile;
/**
 * Creates a {@link ts.TransformerFactory} that adds a new argument to a {@link ts.CallExpression}.
 */
export declare const newArgumentInMethodCallExpressionTransformerFactory: (visitCondition: (node: ts.CallExpression) => boolean, argument: ts.Expression, position?: number, override?: boolean) => <T extends ts.Node>(context: ts.TransformationContext) => (rootNode: T) => ts.SourceFile;
/**
 * Creates a {@link ts.TransformerFactory} that adds a new {@link ts.ImportDeclaration}.
 */
export declare const newImportDeclarationTransformerFactory: (importDeclarationMeta: ImportDeclarationMeta, isDefault?: boolean, isSideEffects?: boolean, singleQuotes?: boolean) => ts.TransformerFactory<ts.SourceFile>;
export declare function createImportDeclaration(importDeclarationMeta: ImportDeclarationMeta, isDefault?: boolean, isSideEffects?: boolean, singleQuotes?: boolean): ts.ImportDeclaration;
export declare function importDeclarationCollides(identifier: Identifier, sourceFile: ts.SourceFile, moduleName?: string, isSideEffects?: boolean): boolean;
/**
 * Determines if a given object is an instance of {@link PropertyAssignment}.
 * @param obj The object to check.
 */
export declare function isPropertyAssignment(obj: object): obj is PropertyAssignment;
