import * as ts from 'typescript';
import { FormatSettings, ImportDeclarationMeta, KeyValuePair, PropertyAssignment } from '../types';
/** Wraps some members of the `ts.factory` for easier creation of custom TS nodes. */
export declare class TypeScriptNodeFactory {
    private formatSettings?;
    /**
     * Creates a new TypeScriptNodeFactory instance.
     * @param formatSettings The formatting settings to apply to the newly-created nodes.
     */
    constructor(formatSettings?: FormatSettings);
    /**
     * Creates a `ts.CallExpression` for an identifier with a method call.
     * @param identifierName Identifier text.
     * @param call Method to call, creating `<identifierName>.<call>()`.
     * @param typeArgs Type arguments for the call, translates to type arguments for generic methods - `myMethod<T, T1, ...>`.
     * @param args Arguments for the call, translates to arguments for the method - `myMethod(arg1, arg2, ...)`.
     * @remarks Create `typeArgs` with methods like `ts.factory.createXXXTypeNode`.
     *
     * ```
     * const typeArg = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);
     * const arg = ts.factory.createNumericLiteral('5');
     * const callExpression = astTransformer.createCallExpression(
     *    'x',
     *    'myGenericFunction',
     *    [typeArg],
     *    [arg]
     * );
     *
     * // This would create the function call
     * x.myGenericFunction<number>(5)
     * ```
     */
    createCallExpression(identifierName: string, call: string, typeArgs?: ts.TypeNode[], args?: ts.Expression[]): ts.CallExpression;
    /**
     * Creates a new object literal expression with the given properties.
     * @param properties The properties to add to the object literal.
     * @param multiline Whether the object literal should be multiline.
     * @param transform A function to transform the value of the property.
     * @remarks A `transform` function should be provided if the `properties` are of type `KeyValuePair<T>`.
     */
    createObjectLiteralExpression(properties: PropertyAssignment[] | KeyValuePair<string>[], multiline?: boolean, transform?: (value: string) => ts.Expression): ts.ObjectLiteralExpression;
    /**
     * Creates an array literal expression with the given elements.
     * @param elements The elements to include in the array literal.
     * @param multiline Whether the array literal should be multiline.
     */
    createArrayLiteralExpression(elements: ts.Expression[], multiline?: boolean): ts.ArrayLiteralExpression;
    createArrayLiteralExpression(elements: PropertyAssignment[], multiline?: boolean): ts.ArrayLiteralExpression;
    /**
     * Creates a node for a named import declaration.
     * @param importDeclarationMeta Metadata for the new import declaration.
     * @param isDefault Whether the import is a default import.
     * @param isSideEffects Whether the import is a side effects import.
     * @returns A named import declaration of the form `import { MyClass } from "my-module"`.
     * @remarks If `isDefault` is `true`, the first element of `identifiers` will be used and
     * the import will be a default import of the form `import MyClass from "my-module"`.
     * @remarks
     * If `isSideEffects` is `true`, all other options are ignored
     * and the import will be a side effects import of the form `import "my-module"`.
     * @reference {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#description|MDN}
     */
    createImportDeclaration(importDeclarationMeta: ImportDeclarationMeta, isDefault?: boolean, isSideEffects?: boolean): ts.ImportDeclaration;
    /**
     * Creates an arrow function with no arity that returns a dynamic import. Takes the form `() => import(path).then(m => m.prop)`.
     * @param path The path to the module to import.
     * @param importedEntity The entity to import from the module.
     */
    createDynamicImport(path: string, importedEntity: string): ts.ArrowFunction;
    /**
     * Creates a property assignment with a zero arity arrow function as the value, which has a call expression in its body.
     * Takes the form `memberName: () => callExpressionName(callExpressionArgs)`.
     * @param memberName The name that will be used in the object literal property assignment.
     * @param callExpressionName The name of the function that will be invoked in the arrow func's body.
     * @param callExpressionArgs The arguments that will be provided to the called function.
     * @remarks The `callExpressionArgs` is considered to be a string literal.
     */
    createArrowFunctionWithCallExpression(memberName: string, callExpressionName: string, callExpressionArgs?: string): PropertyAssignment;
    /**
     * Maps a `KeyValuePair` type to a `ts.ObjectLiteralElementLike` type.
     * @param kvp The key-value pair to map.
     * @param transform Resolves the `ts.Expression` for the the initializer of the `ts.ObjectLiteralElementLike`.
     */
    private mapKeyValuePairToObjectLiteral;
}
