"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeScriptAstTransformer = void 0;
const ts = __importStar(require("typescript"));
const crypto = __importStar(require("crypto"));
const types_1 = require("../types");
const TypeScriptFormattingService_1 = require("./TypeScriptFormattingService");
const TransformerFactories_1 = require("./TransformerFactories");
const TypeScriptExpressionCollector_1 = require("./TypeScriptExpressionCollector");
const TypeScriptNodeFactory_1 = require("./TypeScriptNodeFactory");
/**
 * Applies changes to a `TypeScript` source file through `AST` mutations.
 */
class TypeScriptAstTransformer {
    /**
     * Create a new `TypeScriptAstTransformer` instance for the given source file.
     * @param sourceFile The source file to update.
     * @param printerOptions Options to use when printing the source file.
     * @param customCompilerOptions Custom compiler options to use when transforming the source file.
     * @param formatSettings Custom formatting settings to apply. If provided, a {@link TypeScriptFormattingService} will be initialized.
     */
    constructor(sourceFile, printerOptions, customCompilerOptions, formatSettings) {
        this.sourceFile = sourceFile;
        this.printerOptions = printerOptions;
        this.customCompilerOptions = customCompilerOptions;
        this.formatSettings = formatSettings;
        /** Map of all transformations to apply to the source file. */
        this.transformations = new Map();
        if (formatSettings) {
            this.formatter = new TypeScriptFormattingService_1.TypeScriptFormattingService(sourceFile.fileName, formatSettings);
        }
        this._defaultCompilerOptions = { pretty: true };
        this._expressionCollector = new TypeScriptExpressionCollector_1.TypeScriptExpressionCollector();
        this._factory = new TypeScriptNodeFactory_1.TypeScriptNodeFactory(formatSettings);
        this._flatNodeRelations = this.createNodeRelationsMap(this.sourceFile);
    }
    /** A map of nodes with their parents. */
    get flatNodeRelations() {
        return this._flatNodeRelations;
    }
    /**
     * The printer instance to use to print the source file after modifications.
     */
    get printer() {
        if (!this._printer) {
            this._printer = ts.createPrinter(this.printerOptions);
        }
        return this._printer;
    }
    /**
     * The compiler options to use when transforming the source file.
     */
    get compilerOptions() {
        return Object.assign({}, this._defaultCompilerOptions, this.customCompilerOptions);
    }
    /**
     * Looks up a {@link ts.PropertyAssignment} in the `AST`.
     * @param visitCondition The condition by which the {@link ts.PropertyAssignment} is found.
     * @param lastMatch Whether to return the last match found. If not set, the first match will be returned.
     */
    findPropertyAssignment(visitCondition, lastMatch = false) {
        let propertyAssignment;
        const visitor = (node) => {
            if (ts.isPropertyAssignment(node) && visitCondition(node)) {
                return (propertyAssignment = node);
            }
            if (!propertyAssignment || lastMatch) {
                return ts.visitEachChild(node, visitor, undefined);
            }
            return node;
        };
        ts.visitNode(this.sourceFile, visitor, ts.isPropertyAssignment);
        return propertyAssignment;
    }
    /**
     * Searches the `AST` for a variable declaration with the given name and type.
     * @param name The name of the variable to look for.
     * @param type The type of the variable to look for.
     * @returns The variable declaration if found, otherwise `undefined`.
     */
    findVariableDeclaration(name, type) {
        let declaration;
        ts.forEachChild(this.sourceFile, (node) => {
            var _a;
            if (ts.isVariableDeclaration(node) &&
                node.name.getText() === name &&
                ((_a = node.type) === null || _a === void 0 ? void 0 : _a.getText()) === type) {
                declaration = node;
            }
            else if (ts.isVariableStatement(node)) {
                declaration = node.declarationList.declarations.find((declaration) => {
                    var _a;
                    return declaration.name.getText() === name &&
                        ((_a = declaration.type) === null || _a === void 0 ? void 0 : _a.getText()) === type;
                });
            }
            // handle variable declaration lists (ts.isVariableDeclarationList)?
            // const a = 5, b = 6...;
        });
        return declaration;
    }
    /**
     * Traverses the {@link flatNodeRelations} up to find a node that satisfies the given condition.
     * @param node The starting point of the search.
     * @param condition The condition to satisfy.
     * @returns The node's ancestor that satisfies the condition, `undefined` if none is found.
     */
    findNodeAncestor(node, condition) {
        if (condition(node)) {
            return node;
        }
        const parent = this.flatNodeRelations.get(node);
        if (parent) {
            return this.findNodeAncestor(parent, condition);
        }
        // no parent node satisfies the condition
        return undefined;
    }
    requestNewMemberInObjectLiteral(visitCondition, propertyNameOrAssignment, propertyValue, options) {
        let newProperty;
        if (propertyNameOrAssignment instanceof Object) {
            newProperty = ts.factory.createPropertyAssignment(propertyNameOrAssignment.name, propertyNameOrAssignment.value);
        }
        else if (propertyValue && typeof propertyValue !== 'string') {
            newProperty = ts.factory.createPropertyAssignment(ts.factory.createIdentifier(propertyNameOrAssignment), propertyValue);
        }
        else {
            throw new Error('Must provide property value.');
        }
        const transformerFactory = (0, TransformerFactories_1.newMemberInObjectLiteralTransformerFactory)(newProperty, visitCondition, this._expressionCollector, options);
        this.requestChange(types_1.ChangeType.NewNode, transformerFactory, types_1.SyntaxKind.PropertyAssignment, newProperty);
    }
    /**
     * Creates a request that will resolve during {@link finalize} for a new property assignment that has a `JSX` value.
     * The member is added in an {@link ts.ObjectLiteralExpression}.
     * @param visitCondition The condition by which the {@link ts.ObjectLiteralExpression} is found.
     * @param propertyName The name of the property that will be added.
     * @param propertyValue The value of the property that will be added.
     * @param jsxAttributes The `JSX` attributes to add to the `JSX` element.
     *
     * @remarks Creates a property assignment of the form `{ propertyName: <propertyValue /> }` in the object literal.
     */
    requestJsxMemberInObjectLiteral(visitCondition, propertyName, propertyValue, jsxAttributes) {
        const jsxElement = ts.factory.createJsxSelfClosingElement(ts.factory.createIdentifier(propertyValue), undefined, // type arguments
        jsxAttributes);
        this.requestNewMemberInObjectLiteral(visitCondition, propertyName, jsxElement);
    }
    requestNewMembersInArrayLiteral(visitCondition, expressionOrPropertyAssignment, anchorElement, options) {
        let elements;
        const isExpression = expressionOrPropertyAssignment.every((e) => ts.isExpression(e));
        if (isExpression) {
            elements = expressionOrPropertyAssignment;
        }
        else {
            elements = expressionOrPropertyAssignment.map((property) => this._factory.createObjectLiteralExpression([property], options === null || options === void 0 ? void 0 : options.multiline));
        }
        const transformerFactory = (0, TransformerFactories_1.newMemberInArrayLiteralTransformerFactory)(visitCondition, elements, anchorElement, options);
        this.requestChange(types_1.ChangeType.NewNode, transformerFactory, isExpression ? types_1.SyntaxKind.Expression : types_1.SyntaxKind.PropertyAssignment, ts.factory.createNodeArray(elements));
    }
    /**
     * Creates a request that will resolve during {@link finalize} which sorts the elements in an {@link ts.ArrayLiteralExpression}}.
     * @param visitCondition The condition by which the {@link ts.ArrayLiteralExpression} is found.
     * @param sortCondition The sorting function to apply to the array's elements.
     *
     * @remarks The {@link sortCondition} function should return a negative number if `a` should come before `b`,
     *  a positive number if `a` should come after `b`, or zero if they are equal.
     *
     * Uses {@link Array.prototype.sort} internally.
     */
    requestSortInArrayLiteral(visitCondition, sortCondition) {
        const transformerFactory = (0, TransformerFactories_1.sortInArrayLiteralTransformerFactory)(visitCondition, sortCondition);
        this.requestChange(types_1.ChangeType.NodeUpdate, transformerFactory, types_1.SyntaxKind.ArrayLiteralExpression, null // assume the nodes of the matched array literal
        );
    }
    /**
     * Creates a request that will resolve during {@link finalize} which adds a new argument to a method call expression.
     * @param visitCondition The condition by which the method call expression is found.
     * @param argument The argument to add to the method call.
     * @param position The position in the argument list to add the new argument.
     * @param override Whether to override the argument at the given position.
     * @remarks If {@link position} is not provided or is less than zero, the argument will be added at the end of the argument list.
     */
    requestNewArgumentInMethodCallExpression(visitCondition, argument, position = -1, override = false) {
        const transformerFactory = (0, TransformerFactories_1.newArgumentInMethodCallExpressionTransformerFactory)(visitCondition, argument, position, override);
        this.requestChange(types_1.ChangeType.NewNode, transformerFactory, types_1.SyntaxKind.Expression, argument);
    }
    /**
     * Checks if an {@link ts.ImportDeclaration}'s identifier or alias would collide with an existing one.
     * @param identifier The identifier to check for collisions.
     * @param moduleName The module that the import is for, used for side effects imports.
     * @param isSideEffects If the import is strictly a side effects import.
     * @param sourceFile The source file to check for collisions.
     */
    importDeclarationCollides(identifier, moduleName, isSideEffects = false, sourceFile = this.sourceFile) {
        return (0, TransformerFactories_1.importDeclarationCollides)(identifier, sourceFile, moduleName, isSideEffects);
    }
    /**
     * Creates a request that will resolve during {@link finalize} which adds an {@link ts.ImportDeclaration} to the source file.
     * @param importDeclarationMeta Metadata for the new {@link ts.ImportDeclaration}.
     * @param isDefault Whether the import is a default import.
     * @param isSideEffects Whether the import is a side effects import.
     * @remarks If {@link isDefault} is `true`, the first identifier will be used and
     * the import will be a default import of the form `import MyClass from "my-module"`.
     * @remarks If {@link isSideEffects} is `true`, all other options are ignored
     * and the import will be a side effects import of the form `import "my-module"`.
     * @reference {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#description|MDN}
     */
    requestNewImportDeclaration(importDeclarationMeta, isDefault = false, isSideEffects = false) {
        var _a;
        const transformerFactory = (0, TransformerFactories_1.newImportDeclarationTransformerFactory)(importDeclarationMeta, isDefault, isSideEffects, ((_a = this.formatSettings) === null || _a === void 0 ? void 0 : _a.singleQuotes) || false);
        const identifiers = Array.isArray(importDeclarationMeta.identifiers)
            ? ts.factory.createNodeArray(importDeclarationMeta.identifiers.map((i) => ts.factory.createIdentifier(i.name || i.alias)))
            : ts.factory.createIdentifier(importDeclarationMeta.identifiers.name ||
                importDeclarationMeta.identifiers.alias);
        this.requestChange(types_1.ChangeType.NewNode, transformerFactory, types_1.SyntaxKind.ImportDeclaration, identifiers);
    }
    /**
     * Applies the requested changes to the {@link ts.SourceFile}.
     * @remarks Does not mutate the original {@link ts.SourceFile}. Instead, it creates a new one with the changes applied.
     */
    applyChanges() {
        let clone = this.sourceFile.getSourceFile();
        for (const [_id, transformer] of this.transformations) {
            clone = ts.transform(clone, [transformer.transformerFactory], this.compilerOptions).transformed[0];
            this._flatNodeRelations = this.createNodeRelationsMap(clone);
        }
        this.transformations.clear();
        return clone;
    }
    /**
     * Applies all transformations, parses the `AST` and returns the resulting source code.
     * @remarks This method should be called after all modifications are ready to be applied to the `AST`.
     * If a {@link formatter} is present, it will be used to format the source code and update the file on the FS.
     */
    finalize() {
        const finalSource = this.applyChanges();
        if (this.formatter) {
            return this.formatter.applyFormatting(finalSource);
        }
        return this.printer.printFile(finalSource);
    }
    /**
     * Requests a change to the source file.
     * @param type The type of change to request.
     * @param transformerFactory The transformer to apply to the source file during finalization.
     * @param syntaxKind The syntax kind of the node to change.
     * @param node The affected node.
     * @param relatedChangeId The ID of the change request that should be applied before this one.
     * @remarks All aggregated changes will be applied during {@link finalize}.
     */
    requestChange(type, transformerFactory, syntaxKind, node) {
        const id = crypto.randomUUID();
        this.transformations.set(id, {
            id,
            type,
            transformerFactory,
            syntaxKind,
            node,
        });
    }
    /**
     * Creates a flat map of nodes with their parent nodes.
     * @param rootNode The node to create a map for.
     */
    createNodeRelationsMap(rootNode) {
        const flatNodeRelations = new Map();
        const visit = (node, parent) => {
            if (parent) {
                flatNodeRelations.set(node, parent);
            }
            ts.forEachChild(node, (child) => visit(child, node));
        };
        visit(rootNode, null);
        return flatNodeRelations;
    }
}
exports.TypeScriptAstTransformer = TypeScriptAstTransformer;
