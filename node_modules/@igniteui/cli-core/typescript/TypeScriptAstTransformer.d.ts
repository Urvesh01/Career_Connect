import * as ts from 'typescript';
import { FormattingService, PropertyAssignment, Identifier, ImportDeclarationMeta, FormatSettings, ChangeRequest, ObjectLiteralExpressionEditOptions, ArrayLiteralExpressionEditOptions } from '../types';
/**
 * Applies changes to a `TypeScript` source file through `AST` mutations.
 */
export declare class TypeScriptAstTransformer {
    readonly sourceFile: ts.SourceFile;
    protected readonly printerOptions?: ts.PrinterOptions;
    protected readonly customCompilerOptions?: ts.CompilerOptions;
    private readonly formatSettings?;
    private _defaultCompilerOptions;
    private _expressionCollector;
    private _factory;
    private _flatNodeRelations;
    private _printer;
    /**
     * Create a new `TypeScriptAstTransformer` instance for the given source file.
     * @param sourceFile The source file to update.
     * @param printerOptions Options to use when printing the source file.
     * @param customCompilerOptions Custom compiler options to use when transforming the source file.
     * @param formatSettings Custom formatting settings to apply. If provided, a {@link TypeScriptFormattingService} will be initialized.
     */
    constructor(sourceFile: ts.SourceFile, printerOptions?: ts.PrinterOptions, customCompilerOptions?: ts.CompilerOptions, formatSettings?: FormatSettings);
    /** Map of all transformations to apply to the source file. */
    readonly transformations: Map<string, ChangeRequest<ts.Node>>;
    /** The formatting service to use when printing the source file. */
    formatter: FormattingService;
    /** A map of nodes with their parents. */
    get flatNodeRelations(): Map<ts.Node, ts.Node>;
    /**
     * The printer instance to use to print the source file after modifications.
     */
    get printer(): ts.Printer;
    /**
     * The compiler options to use when transforming the source file.
     */
    get compilerOptions(): ts.CompilerOptions;
    /**
     * Looks up a {@link ts.PropertyAssignment} in the `AST`.
     * @param visitCondition The condition by which the {@link ts.PropertyAssignment} is found.
     * @param lastMatch Whether to return the last match found. If not set, the first match will be returned.
     */
    findPropertyAssignment(visitCondition: (node: ts.PropertyAssignment) => boolean, lastMatch?: boolean): ts.PropertyAssignment | undefined;
    /**
     * Searches the `AST` for a variable declaration with the given name and type.
     * @param name The name of the variable to look for.
     * @param type The type of the variable to look for.
     * @returns The variable declaration if found, otherwise `undefined`.
     */
    findVariableDeclaration(name: string, type: string): ts.VariableDeclaration | undefined;
    /**
     * Traverses the {@link flatNodeRelations} up to find a node that satisfies the given condition.
     * @param node The starting point of the search.
     * @param condition The condition to satisfy.
     * @returns The node's ancestor that satisfies the condition, `undefined` if none is found.
     */
    findNodeAncestor(node: ts.Node, condition: (node: ts.Node) => boolean): ts.Node | undefined;
    /**
     * Creates a request that will resolve during {@link finalize} for a new {@link ts.PropertyAssignment} in an {@link ts.ObjectLiteralExpression}.
     * @param visitCondition The condition by which the {@link ts.ObjectLiteralExpression} is found.
     * @param propertyAssignment The property that will be added.
     */
    requestNewMemberInObjectLiteral(visitCondition: (node: ts.ObjectLiteralExpression) => boolean, propertyAssignment: PropertyAssignment): void;
    /**
     * Creates a request that will resolve during {@link finalize} for a new {@link ts.PropertyAssignment} in an {@link ts.ObjectLiteralExpression}.
     * @param visitCondition The condition by which the {@link ts.ObjectLiteralExpression} is found.
     * @param propertyName The name of the property that will be added.
     * @param propertyValue The value of the property that will be added.
     * @param options Options to apply when modifying the object literal.
     * @remarks Will update the property's initializer if it already exists.
     */
    requestNewMemberInObjectLiteral(visitCondition: (node: ts.ObjectLiteralExpression) => boolean, propertyName: string, propertyValue: ts.Expression, options?: ObjectLiteralExpressionEditOptions): void;
    /**
     * Creates a request that will resolve during {@link finalize} for a new property assignment that has a `JSX` value.
     * The member is added in an {@link ts.ObjectLiteralExpression}.
     * @param visitCondition The condition by which the {@link ts.ObjectLiteralExpression} is found.
     * @param propertyName The name of the property that will be added.
     * @param propertyValue The value of the property that will be added.
     * @param jsxAttributes The `JSX` attributes to add to the `JSX` element.
     *
     * @remarks Creates a property assignment of the form `{ propertyName: <propertyValue /> }` in the object literal.
     */
    requestJsxMemberInObjectLiteral(visitCondition: (node: ts.ObjectLiteralExpression) => boolean, propertyName: string, propertyValue: string, jsxAttributes?: ts.JsxAttributes): void;
    /**
     * Creates a request that will resolve during {@link finalize} which adds a new element to an {@link ts.ArrayLiteralExpression}.
     * @param visitCondition The condition by which the {@link ts.ArrayLiteralExpression} is found.
     * @param elements The elements that will be added to the {@link ts.ArrayLiteralExpression}.
     * @param anchorElement The element to anchor the new elements to.
     * @param options Options to apply when modifying the {@link ts.ArrayLiteralExpression}.
     * @remarks The {@link anchorElement} must match the type of the elements in the collection.
     */
    requestNewMembersInArrayLiteral(visitCondition: (node: ts.ArrayLiteralExpression) => boolean, elements: ts.Expression[], anchorElement?: ts.Expression | PropertyAssignment, options?: ArrayLiteralExpressionEditOptions): void;
    /**
     * Creates a request that will resolve during {@link finalize} which adds a new element to an {@link ts.ArrayLiteralExpression}.
     * @param visitCondition The condition by which the {@link ts.ArrayLiteralExpression} is found.
     * @param elements The elements that will be added to the {@link ts.ArrayLiteralExpression}.
     * @param anchorElement The element to anchor the new elements to.
     * @param options Options to apply when modifying the {@link ts.ArrayLiteralExpression}.
     * @remarks The {@link anchorElement} must match the type of the elements in the collection.
     */
    requestNewMembersInArrayLiteral(visitCondition: (node: ts.ArrayLiteralExpression) => boolean, elements: PropertyAssignment[], anchorElement?: ts.Expression | PropertyAssignment, options?: ArrayLiteralExpressionEditOptions): void;
    /**
     * Creates a request that will resolve during {@link finalize} which sorts the elements in an {@link ts.ArrayLiteralExpression}}.
     * @param visitCondition The condition by which the {@link ts.ArrayLiteralExpression} is found.
     * @param sortCondition The sorting function to apply to the array's elements.
     *
     * @remarks The {@link sortCondition} function should return a negative number if `a` should come before `b`,
     *  a positive number if `a` should come after `b`, or zero if they are equal.
     *
     * Uses {@link Array.prototype.sort} internally.
     */
    requestSortInArrayLiteral(visitCondition: (node: ts.ArrayLiteralExpression) => boolean, sortCondition: (a: ts.Expression, b: ts.Expression) => number): void;
    /**
     * Creates a request that will resolve during {@link finalize} which adds a new argument to a method call expression.
     * @param visitCondition The condition by which the method call expression is found.
     * @param argument The argument to add to the method call.
     * @param position The position in the argument list to add the new argument.
     * @param override Whether to override the argument at the given position.
     * @remarks If {@link position} is not provided or is less than zero, the argument will be added at the end of the argument list.
     */
    requestNewArgumentInMethodCallExpression(visitCondition: (node: ts.CallExpression) => boolean, argument: ts.Expression, position?: number, override?: boolean): void;
    /**
     * Checks if an {@link ts.ImportDeclaration}'s identifier or alias would collide with an existing one.
     * @param identifier The identifier to check for collisions.
     * @param moduleName The module that the import is for, used for side effects imports.
     * @param isSideEffects If the import is strictly a side effects import.
     * @param sourceFile The source file to check for collisions.
     */
    importDeclarationCollides(identifier: Identifier, moduleName?: string, isSideEffects?: boolean, sourceFile?: ts.SourceFile): boolean;
    /**
     * Creates a request that will resolve during {@link finalize} which adds an {@link ts.ImportDeclaration} to the source file.
     * @param importDeclarationMeta Metadata for the new {@link ts.ImportDeclaration}.
     * @param isDefault Whether the import is a default import.
     * @param isSideEffects Whether the import is a side effects import.
     * @remarks If {@link isDefault} is `true`, the first identifier will be used and
     * the import will be a default import of the form `import MyClass from "my-module"`.
     * @remarks If {@link isSideEffects} is `true`, all other options are ignored
     * and the import will be a side effects import of the form `import "my-module"`.
     * @reference {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#description|MDN}
     */
    requestNewImportDeclaration(importDeclarationMeta: ImportDeclarationMeta, isDefault?: boolean, isSideEffects?: boolean): void;
    /**
     * Applies the requested changes to the {@link ts.SourceFile}.
     * @remarks Does not mutate the original {@link ts.SourceFile}. Instead, it creates a new one with the changes applied.
     */
    applyChanges(): ts.SourceFile;
    /**
     * Applies all transformations, parses the `AST` and returns the resulting source code.
     * @remarks This method should be called after all modifications are ready to be applied to the `AST`.
     * If a {@link formatter} is present, it will be used to format the source code and update the file on the FS.
     */
    finalize(): string;
    /**
     * Requests a change to the source file.
     * @param type The type of change to request.
     * @param transformerFactory The transformer to apply to the source file during finalization.
     * @param syntaxKind The syntax kind of the node to change.
     * @param node The affected node.
     * @param relatedChangeId The ID of the change request that should be applied before this one.
     * @remarks All aggregated changes will be applied during {@link finalize}.
     */
    private requestChange;
    /**
     * Creates a flat map of nodes with their parent nodes.
     * @param rootNode The node to create a map for.
     */
    private createNodeRelationsMap;
}
