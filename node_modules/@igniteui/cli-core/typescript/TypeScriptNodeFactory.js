"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeScriptNodeFactory = void 0;
const ts = __importStar(require("typescript"));
const TransformerFactories_1 = require("./TransformerFactories");
const util_1 = require("../util");
/** Wraps some members of the `ts.factory` for easier creation of custom TS nodes. */
class TypeScriptNodeFactory {
    /**
     * Creates a new TypeScriptNodeFactory instance.
     * @param formatSettings The formatting settings to apply to the newly-created nodes.
     */
    constructor(formatSettings) {
        this.formatSettings = formatSettings;
    }
    /**
     * Creates a `ts.CallExpression` for an identifier with a method call.
     * @param identifierName Identifier text.
     * @param call Method to call, creating `<identifierName>.<call>()`.
     * @param typeArgs Type arguments for the call, translates to type arguments for generic methods - `myMethod<T, T1, ...>`.
     * @param args Arguments for the call, translates to arguments for the method - `myMethod(arg1, arg2, ...)`.
     * @remarks Create `typeArgs` with methods like `ts.factory.createXXXTypeNode`.
     *
     * ```
     * const typeArg = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);
     * const arg = ts.factory.createNumericLiteral('5');
     * const callExpression = astTransformer.createCallExpression(
     *    'x',
     *    'myGenericFunction',
     *    [typeArg],
     *    [arg]
     * );
     *
     * // This would create the function call
     * x.myGenericFunction<number>(5)
     * ```
     */
    createCallExpression(identifierName, call, typeArgs, args) {
        return ts.factory.createCallExpression(ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier(identifierName), call), typeArgs, args);
    }
    /**
     * Creates a new object literal expression with the given properties.
     * @param properties The properties to add to the object literal.
     * @param multiline Whether the object literal should be multiline.
     * @param transform A function to transform the value of the property.
     * @remarks A `transform` function should be provided if the `properties` are of type `KeyValuePair<T>`.
     */
    createObjectLiteralExpression(properties, multiline = false, transform) {
        let propertyAssignments = [];
        if (properties.every(TransformerFactories_1.isPropertyAssignment)) {
            propertyAssignments = properties.map((property) => ts.factory.createPropertyAssignment(property.name, property.value));
        }
        else {
            for (const property of properties) {
                propertyAssignments.push(...this.mapKeyValuePairToObjectLiteral(property, (value) => {
                    var _a;
                    return transform
                        ? transform(value)
                        : ts.factory.createStringLiteral(value, (_a = this.formatSettings) === null || _a === void 0 ? void 0 : _a.singleQuotes);
                }));
            }
        }
        return ts.factory.createObjectLiteralExpression(propertyAssignments, multiline);
    }
    createArrayLiteralExpression(elementsOrProperties, multiline = false) {
        if (elementsOrProperties.every((element) => ts.isExpression(element))) {
            return ts.factory.createArrayLiteralExpression(elementsOrProperties, multiline);
        }
        const propertyAssignments = elementsOrProperties.map((property) => this.createObjectLiteralExpression([property], multiline));
        return ts.factory.createArrayLiteralExpression(propertyAssignments, multiline);
    }
    /**
     * Creates a node for a named import declaration.
     * @param importDeclarationMeta Metadata for the new import declaration.
     * @param isDefault Whether the import is a default import.
     * @param isSideEffects Whether the import is a side effects import.
     * @returns A named import declaration of the form `import { MyClass } from "my-module"`.
     * @remarks If `isDefault` is `true`, the first element of `identifiers` will be used and
     * the import will be a default import of the form `import MyClass from "my-module"`.
     * @remarks
     * If `isSideEffects` is `true`, all other options are ignored
     * and the import will be a side effects import of the form `import "my-module"`.
     * @reference {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#description|MDN}
     */
    createImportDeclaration(importDeclarationMeta, isDefault = false, isSideEffects = false) {
        var _a;
        return (0, TransformerFactories_1.createImportDeclaration)(importDeclarationMeta, isDefault, isSideEffects, ((_a = this.formatSettings) === null || _a === void 0 ? void 0 : _a.singleQuotes) || false);
    }
    /**
     * Creates an arrow function with no arity that returns a dynamic import. Takes the form `() => import(path).then(m => m.prop)`.
     * @param path The path to the module to import.
     * @param importedEntity The entity to import from the module.
     */
    createDynamicImport(path, importedEntity) {
        var _a;
        // create the 'import(path)' expression
        const importExpression = ts.factory.createCallExpression(ts.factory.createIdentifier(util_1.IMPORT_IDENTIFIER_NAME), undefined, // type arguments
        [ts.factory.createStringLiteral(path, (_a = this.formatSettings) === null || _a === void 0 ? void 0 : _a.singleQuotes)]);
        const thenFuncParamName = 'm';
        // create the 'm => m.prop' arrow function
        const thenExprArrowFuncBody = ts.factory.createArrowFunction(undefined, // modifiers
        undefined, // type parameters
        [
            ts.factory.createParameterDeclaration(undefined, // decorators
            undefined, // modifiers
            ts.factory.createIdentifier(thenFuncParamName)),
        ], undefined, ts.factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken), ts.factory.createPropertyAccessChain(ts.factory.createIdentifier(thenFuncParamName), undefined, // question-dot token
        importedEntity));
        // build the '.then(m => m.prop)' expression and add it to the import expression
        const body = ts.factory.createCallExpression(ts.factory.createPropertyAccessExpression(importExpression, util_1.THEN_IDENTIFIER_NAME), undefined, // type arguments
        [thenExprArrowFuncBody]);
        // Create the '() => import(path).then(m => m.prop)' arrow function
        const dynamicImport = ts.factory.createArrowFunction(undefined, // modifiers
        undefined, // type parameters
        [], // parameters
        undefined, // type
        ts.factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken), body);
        return dynamicImport;
    }
    /**
     * Creates a property assignment with a zero arity arrow function as the value, which has a call expression in its body.
     * Takes the form `memberName: () => callExpressionName(callExpressionArgs)`.
     * @param memberName The name that will be used in the object literal property assignment.
     * @param callExpressionName The name of the function that will be invoked in the arrow func's body.
     * @param callExpressionArgs The arguments that will be provided to the called function.
     * @remarks The `callExpressionArgs` is considered to be a string literal.
     */
    createArrowFunctionWithCallExpression(memberName, callExpressionName, callExpressionArgs) {
        var _a;
        const arrowFunction = ts.factory.createArrowFunction(undefined, // modifiers
        undefined, // type parameters
        [], // parameters
        undefined, // type
        ts.factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken), ts.factory.createCallExpression(ts.factory.createIdentifier(callExpressionName), undefined, // type arguments
        callExpressionArgs
            ? [
                ts.factory.createStringLiteral(callExpressionArgs, (_a = this.formatSettings) === null || _a === void 0 ? void 0 : _a.singleQuotes),
            ]
            : []));
        return {
            name: memberName,
            value: arrowFunction,
        };
    }
    /**
     * Maps a `KeyValuePair` type to a `ts.ObjectLiteralElementLike` type.
     * @param kvp The key-value pair to map.
     * @param transform Resolves the `ts.Expression` for the the initializer of the `ts.ObjectLiteralElementLike`.
     */
    mapKeyValuePairToObjectLiteral(kvp, transform) {
        return Object.entries(kvp).map(([key, value]) => ts.factory.createPropertyAssignment(key, transform(value)));
    }
}
exports.TypeScriptNodeFactory = TypeScriptNodeFactory;
