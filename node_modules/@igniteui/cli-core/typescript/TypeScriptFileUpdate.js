"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeScriptFileUpdate = void 0;
const ts = __importStar(require("typescript"));
const TypeScriptAstTransformer_1 = require("./TypeScriptAstTransformer");
const TypeScriptUtils_1 = require("./TypeScriptUtils");
const VisitorConditions_1 = require("./VisitorConditions");
const util_1 = require("../util");
const types_1 = require("../types");
const TypeScriptNodeFactory_1 = require("./TypeScriptNodeFactory");
class TypeScriptFileUpdate {
    /**
     * Creates a new TypeScriptFileUpdate instance for the given file.
     * @param filePath The path to the file that will be updated.
     * @param formatSettings The formatting settings to apply.
     * @param compilerOptions The compiler options to use when transforming the source file.
     */
    constructor(filePath, formatSettings, compilerOptions) {
        this.filePath = filePath;
        this.formatSettings = formatSettings;
        this.astTransformer = new TypeScriptAstTransformer_1.TypeScriptAstTransformer(TypeScriptUtils_1.TypeScriptUtils.getFileSource(filePath, (compilerOptions === null || compilerOptions === void 0 ? void 0 : compilerOptions.jsx) > 0), util_1.TS_PRINTER_OPTIONS, compilerOptions, formatSettings);
        this.factory = new TypeScriptNodeFactory_1.TypeScriptNodeFactory(formatSettings);
    }
    /**
     * Adds a child route to a parent route.
     * @param parentPath The path of the parent route.
     * @param route The child route to add.
     * @param asIdentifier Whether to initialize the {@link RouteTarget.Children} member with an identifier or an array literal.
     * @param multiline Whether to format the new entry as multiline.
     * @remarks The `parentPath` is used to determine where the child route should be added.
     */
    addChildRoute(parentPath, route, asIdentifier = false, multiline = false) {
        if (!route.lazyload) {
            this.requestImportForRouteIdentifier(route);
        }
        const visitCondition = (node) => {
            return node.properties.some((n) => (0, VisitorConditions_1.PropertyAssignmentWithStringLiteralValueCondition)(types_1.RouteTarget.Path, parentPath)(n) &&
                (0, VisitorConditions_1.variableAsParentCondition)(this.astTransformer, util_1.ROUTES_VARIABLE_NAME)(n));
        };
        const initializer = asIdentifier
            ? ts.factory.createIdentifier(route.aliasName || route.identifierName)
            : this.factory.createArrayLiteralExpression([
                this.factory.createObjectLiteralExpression(this.buildRouteStructure(route, multiline), multiline),
            ], multiline);
        this.astTransformer.requestNewMemberInObjectLiteral(visitCondition, types_1.RouteTarget.Children, initializer, { multiline });
    }
    /**
     * Applies all transformations, parses the AST, formats the source code and saves all changes on the FS.
     * @remarks This method should be called after all modifications are ready to be applied to the AST.
     */
    finalize() {
        return this.astTransformer.finalize();
    }
    /**
     * Applies a configuration transformation to a string.
     * @param data The string to transform.
     * @param configuration The items to replace in the string.
     */
    applyConfigTransformation(data, configuration) {
        for (const key in configuration) {
            data = data.replace(new RegExp(util_1.Util.escapeRegExp(key), 'g'), configuration[key]);
        }
        return data;
    }
    /**
     * Converts a string or string array union to array.
     * @param value The value to convert.
     * @param variables Variables to replace in the strings.
     * @remarks Splits strings as comma delimited.
     */
    asArray(value, variables) {
        let result = [];
        if (value) {
            result = typeof value === 'string' ? value.split(/\s*,\s*/) : value;
            result = result.map((x) => this.applyConfigTransformation(x, variables));
        }
        return result;
    }
    /**
     * Creates a side effects import declaration for a given module. Checks if the import has been added already.
     * @param moduleName The name of the module to create an import for.
     * @see {@link TypeScriptAstTransformer.createImportDeclaration}
     */
    requestSideEffectsImportForModule(moduleName) {
        const importMeta = {
            identifiers: { name: '<placeholder>' }, // will be ignored since it's a side effects import
            moduleName,
        };
        this.astTransformer.requestNewImportDeclaration(importMeta, false, // is default
        true // is side effects
        );
    }
    /**
     * Adds an import declaration for an identifier that exists in a route node. Checks if it does not collide with other imports first.
     * @param route The route that contains an identifier to create a declaration for.
     * @see {@link TypeScriptAstTransformer.createImportDeclaration}
     */
    requestImportForRouteIdentifier(route, isDefault = false) {
        if (route.modulePath) {
            // add an import for the given identifier
            const routeIdentifier = {
                name: route.identifierName,
                alias: route.aliasName,
            };
            // if there is an identifierName, there must be a modulePath as well
            this.astTransformer.requestNewImportDeclaration({
                identifiers: routeIdentifier,
                moduleName: route.modulePath,
            }, isDefault);
        }
    }
}
exports.TypeScriptFileUpdate = TypeScriptFileUpdate;
