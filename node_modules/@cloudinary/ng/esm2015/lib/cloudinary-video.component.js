import { Component, Input, ElementRef, EventEmitter, Output } from '@angular/core';
import { CloudinaryVideo } from '@cloudinary/url-gen';
import { cancelCurrentlyRunningPlugins, HtmlVideoLayer } from '@cloudinary/html';
import * as i0 from "@angular/core";
/**
 * @memberOf AngularSDK
 * @type {Component}
 * @description The Cloudinary video component.
 * @prop {CloudinaryVideo} transformation Generated by @cloudinary/url-gen
 * @prop {VideoPoster} transformation Generated by @cloudinary/url-gen
 * @prop {Plugins} plugins Advanced image component plugins lazyload()
 * @prop videoAttributes Optional attributes include controls, loop, muted, poster, preload, autoplay
 * @prop videoEvents Optional video events include play, loadstart, playing, error, ended
 * @prop {VideoSources} sources Optional sources to generate
 * @example
 *  <caption>
 *  Using custom defined resources.
 * </caption>
 *   vid = new CloudinaryVideo('dog', {cloudName: 'demo'});
 *   sources = [
 {
        type: 'mp4',
        codecs: ['vp8', 'vorbis'],
        transcode: videoCodec(auto())
},
 {
        type: 'webm',
        codecs: ['avc1.4D401E', 'mp4a.40.2'],
         transcode: videoCodec(auto())
      }];
 *
 * <advanced-video [cldvid]="vid" [sources]="sources" controls></advanced-video>
 */
export class CloudinaryVideoComponent {
    constructor(el) {
        this.el = el;
        // Event emitters
        this.play = new EventEmitter();
        this.loadstart = new EventEmitter();
        this.playing = new EventEmitter();
        this.error = new EventEmitter();
        this.ended = new EventEmitter();
        // supported video attributes
        this.controls = this.el.nativeElement.attributes.controls;
        this.loop = this.el.nativeElement.attributes.loop;
        this.muted = this.el.nativeElement.attributes.muted;
        this.preload = this.el.nativeElement.attributes.preload;
        this.autoPlay = this.el.nativeElement.attributes.autoplay;
        this.playsInline = this.el.nativeElement.attributes.playsInline;
    }
    /**
     * On init creates a new HTMLVideoLayer instance and initializes with ref to video element,
     * user generated cloudinaryVideo and the plugins to be used.
     */
    ngOnInit() {
        this.htmlVideoLayerInstance = new HtmlVideoLayer(this.el.nativeElement.children[0], this.cldVid, this.sources, this.plugins, this.getVideoAttributes(), this.cldPoster, { useFetchFormat: this.useFetchFormat });
        // check if video should be muted. We need to take care of this here since Angular has a bug with binding the muted
        // attribute
        if (this.muted) {
            this.el.nativeElement.children[0].muted = true;
        }
        // attach ref to innerRef input
        this.attachRef();
    }
    /**
     * On update, we cancel running plugins and update the video instance if the src
     * was changed.
     */
    ngOnChanges() {
        if (this.htmlVideoLayerInstance) {
            cancelCurrentlyRunningPlugins(this.htmlVideoLayerInstance.htmlPluginState);
            this.htmlVideoLayerInstance.update(this.cldVid, this.sources, this.plugins, this.getVideoAttributes(), this.cldPoster);
        }
    }
    /**
     * On destroy, we cancel the currently running plugins.
     */
    ngOnDestroy() {
        // Safely cancel running events on destroy
        cancelCurrentlyRunningPlugins(this.htmlVideoLayerInstance.htmlPluginState);
    }
    /**
     * Returns video attributes.
     */
    getVideoAttributes() {
        return {
            controls: this.controls,
            loop: this.loop,
            muted: this.muted,
            poster: this.poster,
            preload: this.preload,
            autoplay: this.autoPlay,
            playsinline: this.playsInline
        };
    }
    emitPlayEvent() {
        this.play.emit();
    }
    emitLoadstartEvent() {
        this.loadstart.emit();
    }
    emitPlayingEvent() {
        this.playing.emit();
    }
    emitErrorEvent() {
        this.error.emit();
    }
    emitEndedEvent() {
        this.ended.emit();
    }
    /**
     * Attach both this.videoRef and props.innerRef as ref to the given element.
     */
    attachRef() {
        if (this.innerRef) {
            this.innerRef.nativeElement = this.el.nativeElement.children[0];
        }
    }
}
CloudinaryVideoComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: CloudinaryVideoComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
CloudinaryVideoComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: CloudinaryVideoComponent, selector: "advanced-video", inputs: { cldVid: "cldVid", cldPoster: "cldPoster", sources: "sources", plugins: "plugins", poster: "poster", innerRef: "innerRef", useFetchFormat: "useFetchFormat" }, outputs: { play: "play", loadstart: "loadstart", playing: "playing", error: "error", ended: "ended" }, usesOnChanges: true, ngImport: i0, template: `<video (play)="emitPlayEvent()"
                    (loadstart)="emitLoadstartEvent()"
                    (playing)="emitPlayingEvent()"
                    (error)="emitErrorEvent"
                    (ended)="emitEndedEvent">
            </video>`, isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: CloudinaryVideoComponent, decorators: [{
            type: Component,
            args: [{
                    // tslint:disable-next-line:component-selector
                    selector: 'advanced-video',
                    template: `<video (play)="emitPlayEvent()"
                    (loadstart)="emitLoadstartEvent()"
                    (playing)="emitPlayingEvent()"
                    (error)="emitErrorEvent"
                    (ended)="emitEndedEvent">
            </video>`,
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { cldVid: [{
                type: Input,
                args: ['cldVid']
            }], cldPoster: [{
                type: Input,
                args: ['cldPoster']
            }], sources: [{
                type: Input,
                args: ['sources']
            }], plugins: [{
                type: Input,
                args: ['plugins']
            }], poster: [{
                type: Input,
                args: ['poster']
            }], innerRef: [{
                type: Input,
                args: ['innerRef']
            }], useFetchFormat: [{
                type: Input,
                args: ['useFetchFormat']
            }], play: [{
                type: Output
            }], loadstart: [{
                type: Output
            }], playing: [{
                type: Output
            }], error: [{
                type: Output
            }], ended: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWRpbmFyeS12aWRlby5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL2Nsb3VkaW5hcnktdmlkZW8uY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQVUsS0FBSyxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUF1QixNQUFNLGVBQWUsQ0FBQztBQUMvRyxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0scUJBQXFCLENBQUM7QUFFcEQsT0FBTyxFQUNMLDZCQUE2QixFQUM3QixjQUFjLEVBSWYsTUFBTSxrQkFBa0IsQ0FBQzs7QUFHMUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E0Qkc7QUFXSCxNQUFNLE9BQU8sd0JBQXdCO0lBQ25DLFlBQW9CLEVBQWM7UUFBZCxPQUFFLEdBQUYsRUFBRSxDQUFZO1FBVWxDLGlCQUFpQjtRQUNQLFNBQUksR0FBc0IsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUM3QyxjQUFTLEdBQXNCLElBQUksWUFBWSxFQUFFLENBQUM7UUFDbEQsWUFBTyxHQUFzQixJQUFJLFlBQVksRUFBRSxDQUFDO1FBQ2hELFVBQUssR0FBc0IsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUM5QyxVQUFLLEdBQXNCLElBQUksWUFBWSxFQUFFLENBQUM7UUFFeEQsNkJBQTZCO1FBQzdCLGFBQVEsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDO1FBQ3JELFNBQUksR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDO1FBQzdDLFVBQUssR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDO1FBQy9DLFlBQU8sR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMs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cEMsU0FBUzttQkFBQztvQkFDVCw4Q0FBOEM7b0JBQzlDLFFBQVEsRUFBRSxnQkFBZ0I7b0JBQzFCLFFBQVEsRUFBRTs7Ozs7cUJBS1M7aUJBQ3BCO2lHQUlrQixNQUFNO3NCQUF0QixLQUFLO3VCQUFDLFFBQVE7Z0JBQ0ssU0FBUztzQkFBNUIsS0FBSzt1QkFBQyxXQUFXO2dCQUNBLE9BQU87c0JBQXhCLEtBQUs7dUJBQUMsU0FBUztnQkFDRSxPQUFPO3NCQUF4QixLQUFLO3VCQUFDLFNBQVM7Z0JBQ0MsTUFBTTtzQkFBdEIsS0FBSzt1QkFBQyxRQUFRO2dCQUNJLFFBQVE7c0JBQTFCLEtBQUs7dUJBQUMsVUFBVTtnQkFDUSxjQUFjO3NCQUF0QyxLQUFLO3VCQUFDLGdCQUFnQjtnQkFHYixJQUFJO3NCQUFiLE1BQU07Z0JBQ0csU0FBUztzQkFBbEIsTUFBTTtnQkFDRyxPQUFPO3NCQUFoQixNQUFNO2dCQUNHLEtBQUs7c0JBQWQsTUFBTTtnQkFDRyxLQUFLO3NCQUFkLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbXBvbmVudCwgT25Jbml0LCBJbnB1dCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBPdXRwdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q2xvdWRpbmFyeVZpZGVvfSBmcm9tICdAY2xvdWRpbmFyeS91cmwtZ2VuJztcblxuaW1wb3J0IHtcbiAgY2FuY2VsQ3VycmVudGx5UnVubmluZ1BsdWdpbnMsXG4gIEh0bWxWaWRlb0xheWVyLFxuICBQbHVnaW5zLFxuICBWaWRlb1Bvc3RlcixcbiAgVmlkZW9Tb3VyY2VzXG59IGZyb20gJ0BjbG91ZGluYXJ5L2h0bWwnO1xuXG5cbi8qKlxuICogQG1lbWJlck9mIEFuZ3VsYXJTREtcbiAqIEB0eXBlIHtDb21wb25lbnR9XG4gKiBAZGVzY3JpcHRpb24gVGhlIENsb3VkaW5hcnkgdmlkZW8gY29tcG9uZW50LlxuICogQHByb3Age0Nsb3VkaW5hcnlWaWRlb30gdHJhbnNmb3JtYXRpb24gR2VuZXJhdGVkIGJ5IEBjbG91ZGluYXJ5L3VybC1nZW5cbiAqIEBwcm9wIHtWaWRlb1Bvc3Rlcn0gdHJhbnNmb3JtYXRpb24gR2VuZXJhdGVkIGJ5IEBjbG91ZGluYXJ5L3VybC1nZW5cbiAqIEBwcm9wIHtQbHVnaW5zfSBwbHVnaW5zIEFkdmFuY2VkIGltYWdlIGNvbXBvbmVudCBwbHVnaW5zIGxhenlsb2FkKClcbiAqIEBwcm9wIHZpZGVvQXR0cmlidXRlcyBPcHRpb25hbCBhdHRyaWJ1dGVzIGluY2x1ZGUgY29udHJvbHMsIGxvb3AsIG11dGVkLCBwb3N0ZXIsIHByZWxvYWQsIGF1dG9wbGF5XG4gKiBAcHJvcCB2aWRlb0V2ZW50cyBPcHRpb25hbCB2aWRlbyBldmVudHMgaW5jbHVkZSBwbGF5LCBsb2Fkc3RhcnQsIHBsYXlpbmcsIGVycm9yLCBlbmRlZFxuICogQHByb3Age1ZpZGVvU291cmNlc30gc291cmNlcyBPcHRpb25hbCBzb3VyY2VzIHRvIGdlbmVyYXRlXG4gKiBAZXhhbXBsZVxuICogIDxjYXB0aW9uPlxuICogIFVzaW5nIGN1c3RvbSBkZWZpbmVkIHJlc291cmNlcy5cbiAqIDwvY2FwdGlvbj5cbiAqICAgdmlkID0gbmV3IENsb3VkaW5hcnlWaWRlbygnZG9nJywge2Nsb3VkTmFtZTogJ2RlbW8nfSk7XG4gKiAgIHNvdXJjZXMgPSBbXG4ge1xuICAgICAgICB0eXBlOiAnbXA0JyxcbiAgICAgICAgY29kZWNzOiBbJ3ZwOCcsICd2b3JiaXMnXSxcbiAgICAgICAgdHJhbnNjb2RlOiB2aWRlb0NvZGVjKGF1dG8oKSlcbn0sXG4ge1xuICAgICAgICB0eXBlOiAnd2VibScsXG4gICAgICAgIGNvZGVjczogWydhdmMxLjRENDAxRScsICdtcDRhLjQwLjInXSxcbiAgICAgICAgIHRyYW5zY29kZTogdmlkZW9Db2RlYyhhdXRvKCkpXG4gICAgICB9XTtcbiAqXG4gKiA8YWR2YW5jZWQtdmlkZW8gW2NsZHZpZF09XCJ2aWRcIiBbc291cmNlc109XCJzb3VyY2VzXCIgY29udHJvbHM+PC9hZHZhbmNlZC12aWRlbz5cbiAqL1xuQENvbXBvbmVudCh7XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpjb21wb25lbnQtc2VsZWN0b3JcbiAgc2VsZWN0b3I6ICdhZHZhbmNlZC12aWRlbycsXG4gIHRlbXBsYXRlOiBgPHZpZGVvIChwbGF5KT1cImVtaXRQbGF5RXZlbnQoKVwiXG4gICAgICAgICAgICAgICAgICAgIChsb2Fkc3RhcnQpPVwiZW1pdExvYWRzdGFydEV2ZW50KClcIlxuICAgICAgICAgICAgICAgICAgICAocGxheWluZyk9XCJlbWl0UGxheWluZ0V2ZW50KClcIlxuICAgICAgICAgICAgICAgICAgICAoZXJyb3IpPVwiZW1pdEVycm9yRXZlbnRcIlxuICAgICAgICAgICAgICAgICAgICAoZW5kZWQpPVwiZW1pdEVuZGVkRXZlbnRcIj5cbiAgICAgICAgICAgIDwvdmlkZW8+YCxcbn0pXG5leHBvcnQgY2xhc3MgQ2xvdWRpbmFyeVZpZGVvQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZWw6IEVsZW1lbnRSZWYpIHsgfVxuXG4gIEBJbnB1dCgnY2xkVmlkJykgY2xkVmlkOiBDbG91ZGluYXJ5VmlkZW87XG4gIEBJbnB1dCgnY2xkUG9zdGVyJykgY2xkUG9zdGVyOiBWaWRlb1Bvc3RlcjtcbiAgQElucHV0KCdzb3VyY2VzJykgc291cmNlczogVmlkZW9Tb3VyY2VzO1xuICBASW5wdXQoJ3BsdWdpbnMnKSBwbHVnaW5zOiBQbHVnaW5zO1xuICBASW5wdXQoJ3Bvc3RlcicpIHBvc3Rlcjogc3RyaW5nO1xuICBASW5wdXQoJ2lubmVyUmVmJykgaW5uZXJSZWY6IEVsZW1lbnRSZWY7XG4gIEBJbnB1dCgndXNlRmV0Y2hGb3JtYXQnKSB1c2VGZXRjaEZvcm1hdDogYm9vbGVhbjtcblxuICAvLyBFdmVudCBlbWl0dGVyc1xuICBAT3V0cHV0KCkgcGxheTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIEBPdXRwdXQoKSBsb2Fkc3RhcnQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBAT3V0cHV0KCkgcGxheWluZzogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIEBPdXRwdXQoKSBlcnJvcjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIEBPdXRwdXQoKSBlbmRlZDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLy8gc3VwcG9ydGVkIHZpZGVvIGF0dHJpYnV0ZXNcbiAgY29udHJvbHMgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuYXR0cmlidXRlcy5jb250cm9scztcbiAgbG9vcCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudC5hdHRyaWJ1dGVzLmxvb3A7XG4gIG11dGVkID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50LmF0dHJpYnV0ZXMubXV0ZWQ7XG4gIHByZWxvYWQgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuYXR0cmlidXRlcy5wcmVsb2FkO1xuICBhdXRvUGxheSA9IHRoaXMuZWwubmF0aXZlRWxlbWVudC5hdHRyaWJ1dGVzLmF1dG9wbGF5O1xuICBwbGF5c0lubGluZSA9IHRoaXMuZWwubmF0aXZlRWxlbWVudC5hdHRyaWJ1dGVzLnBsYXlzSW5saW5lO1xuXG4gIHByaXZhdGUgaHRtbFZpZGVvTGF5ZXJJbnN0YW5jZTogSHRtbFZpZGVvTGF5ZXI7XG5cbiAgLyoqXG4gICAqIE9uIGluaXQgY3JlYXRlcyBhIG5ldyBIVE1MVmlkZW9MYXllciBpbnN0YW5jZSBhbmQgaW5pdGlhbGl6ZXMgd2l0aCByZWYgdG8gdmlkZW8gZWxlbWVudCxcbiAgICogdXNlciBnZW5lcmF0ZWQgY2xvdWRpbmFyeVZpZGVvIGFuZCB0aGUgcGx1Z2lucyB0byBiZSB1c2VkLlxuICAgKi9cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5odG1sVmlkZW9MYXllckluc3RhbmNlID0gbmV3IEh0bWxWaWRlb0xheWVyKFxuICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzBdLFxuICAgICAgdGhpcy5jbGRWaWQsXG4gICAgICB0aGlzLnNvdXJjZXMsXG4gICAgICB0aGlzLnBsdWdpbnMsXG4gICAgICB0aGlzLmdldFZpZGVvQXR0cmlidXRlcygpLFxuICAgICAgdGhpcy5jbGRQb3N0ZXIsXG4gICAgICB7IHVzZUZldGNoRm9ybWF0OiB0aGlzLnVzZUZldGNoRm9ybWF0IH1cbiAgICAgICk7XG5cbiAgICAvLyBjaGVjayBpZiB2aWRlbyBzaG91bGQgYmUgbXV0ZWQuIFdlIG5lZWQgdG8gdGFrZSBjYXJlIG9mIHRoaXMgaGVyZSBzaW5jZSBBbmd1bGFyIGhhcyBhIGJ1ZyB3aXRoIGJpbmRpbmcgdGhlIG11dGVkXG4gICAgLy8gYXR0cmlidXRlXG4gICAgaWYgKHRoaXMubXV0ZWQpIHtcbiAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXS5tdXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gYXR0YWNoIHJlZiB0byBpbm5lclJlZiBpbnB1dFxuICAgIHRoaXMuYXR0YWNoUmVmKCk7XG4gIH1cblxuICAvKipcbiAgICogT24gdXBkYXRlLCB3ZSBjYW5jZWwgcnVubmluZyBwbHVnaW5zIGFuZCB1cGRhdGUgdGhlIHZpZGVvIGluc3RhbmNlIGlmIHRoZSBzcmNcbiAgICogd2FzIGNoYW5nZWQuXG4gICAqL1xuICBuZ09uQ2hhbmdlcygpIHtcbiAgICBpZiAodGhpcy5odG1sVmlkZW9MYXllckluc3RhbmNlKSB7XG4gICAgICBjYW5jZWxDdXJyZW50bHlSdW5uaW5nUGx1Z2lucyh0aGlzLmh0bWxWaWRlb0xheWVySW5zdGFuY2UuaHRtbFBsdWdpblN0YXRlKTtcbiAgICAgIHRoaXMuaHRtbFZpZGVvTGF5ZXJJbnN0YW5jZS51cGRhdGUodGhpcy5jbGRWaWQsIHRoaXMuc291cmNlcywgdGhpcy5wbHVnaW5zLCB0aGlzLmdldFZpZGVvQXR0cmlidXRlcygpLCB0aGlzLmNsZFBvc3Rlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGRlc3Ryb3ksIHdlIGNhbmNlbCB0aGUgY3VycmVudGx5IHJ1bm5pbmcgcGx1Z2lucy5cbiAgICovXG4gIG5nT25EZXN0cm95KCkge1xuICAgIC8vIFNhZmVseSBjYW5jZWwgcnVubmluZyBldmVudHMgb24gZGVzdHJveVxuICAgIGNhbmNlbEN1cnJlbnRseVJ1bm5pbmdQbHVnaW5zKHRoaXMuaHRtbFZpZGVvTGF5ZXJJbnN0YW5jZS5odG1sUGx1Z2luU3RhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdmlkZW8gYXR0cmlidXRlcy5cbiAgICovXG4gIGdldFZpZGVvQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29udHJvbHM6IHRoaXMuY29udHJvbHMsXG4gICAgICBsb29wOiB0aGlzLmxvb3AsXG4gICAgICBtdXRlZDogdGhpcy5tdXRlZCxcbiAgICAgIHBvc3RlcjogdGhpcy5wb3N0ZXIsXG4gICAgICBwcmVsb2FkOiB0aGlzLnByZWxvYWQsXG4gICAgICBhdXRvcGxheTogdGhpcy5hdXRvUGxheSxcbiAgICAgIHBsYXlzaW5saW5lOiB0aGlzLnBsYXlzSW5saW5lXG4gICAgfTtcbiAgfVxuXG4gIGVtaXRQbGF5RXZlbnQoKSB7XG4gICAgdGhpcy5wbGF5LmVtaXQoKTtcbiAgfVxuXG4gIGVtaXRMb2Fkc3RhcnRFdmVudCgpIHtcbiAgICB0aGlzLmxvYWRzdGFydC5lbWl0KCk7XG4gIH1cblxuICBlbWl0UGxheWluZ0V2ZW50KCkge1xuICAgIHRoaXMucGxheWluZy5lbWl0KCk7XG4gIH1cblxuICBlbWl0RXJyb3JFdmVudCgpIHtcbiAgICB0aGlzLmVycm9yLmVtaXQoKTtcbiAgfVxuXG4gIGVtaXRFbmRlZEV2ZW50KCkge1xuICAgIHRoaXMuZW5kZWQuZW1pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCBib3RoIHRoaXMudmlkZW9SZWYgYW5kIHByb3BzLmlubmVyUmVmIGFzIHJlZiB0byB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICovXG4gIGF0dGFjaFJlZigpIHtcbiAgICBpZiAodGhpcy5pbm5lclJlZikge1xuICAgICAgdGhpcy5pbm5lclJlZi5uYXRpdmVFbGVtZW50ID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzBdO1xuICAgIH1cbiAgfVxufVxuIl19